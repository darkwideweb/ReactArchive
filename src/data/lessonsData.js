const lessonsData = [
  {
    "title": "Введение в React",
    "description": "Изучите основы React и как создавать компоненты.",
    "topic": "Основы React",
    "theory": "React — это библиотека JavaScript, разработанная Facebook, предназначенная для создания динамичных и интерактивных пользовательских интерфейсов. Основная концепция React заключается в использовании компонентов, которые представляют собой независимые и многоразовые части интерфейса. Компоненты могут быть функциональными или классовыми, и они позволяют разбивать интерфейс на небольшие, управляемые и переиспользуемые части. JSX (JavaScript XML) — это синтаксис, который позволяет писать HTML-подобный код внутри JavaScript. Это делает код более читабельным и удобным для разработчиков. React использует виртуальный DOM для эффективного обновления реального DOM. Виртуальный DOM — это легковесная копия реального DOM, которая позволяет минимизировать количество операций по его изменению. Это значительно увеличивает производительность приложений, так как React обновляет только те части интерфейса, которые изменились.",
    "codeExamples": [
      "import React from 'react';\n\nfunction App() {\n  return (\n    <div>Hello, React!</div>\n  );\n}\n\nexport default App;",
      "import React from 'react';\n\nconst Greeting = () => <h1>Hello, World!</h1>;\n\nexport default Greeting;"
    ],
    "questions": [
      "Что такое компонент в React?",
      "Какой синтаксис используется для создания функционального компонента?",
      "Как вернуть JSX из компонента?"
    ]
  },  
  {
    "title": "Компоненты и Пропсы",
    "description": "Узнайте, как использовать компоненты и пропсы в React.",
    "topic": "Компоненты и пропсы в React",
    "theory": "В React компоненты — это строительные блоки вашего приложения. Компоненты могут быть функциональными или классовыми, и они могут содержать другие компоненты. Пропсы (свойства) — это способ передачи данных и функций от родительского компонента к дочерним. Они позволяют настраивать компоненты и передавать в них данные, которые могут быть использованы для отображения информации или для обработки событий. Благодаря пропсам, компоненты становятся более гибкими и переиспользуемыми. Пропсы могут принимать любые типы данных, включая строки, числа, массивы, объекты и даже функции. Это позволяет создавать динамичные и интерактивные интерфейсы. Важно помнить, что пропсы являются неизменяемыми — дочерние компоненты не могут изменять их значения. Это обеспечивает односторонний поток данных, что облегчает понимание и отладку приложения.",
    "codeExamples": [
      "function Welcome(props) {\n  return <h1>Привет, {props.name}</h1>;\n}",
      "const element = <Welcome name='Nikita' />;"
    ],
    "questions": [
      "Что такое пропсы в React?",
      "Как передать данные от родительского компонента дочернему?",
      "Какой тип данных могут принимать пропсы?",
      "Почему пропсы являются неизменяемыми и как это влияет на архитектуру приложения?"
    ]
},
{ 
  "title": "События в React",
  "description": "Узнайте, как обрабатывать события в React.",
  "topic": "События в React",
  "theory": "События в React обрабатываются с помощью обработчиков событий, которые прикрепляются к элементам через атрибуты, такие как `onClick`, `onChange` и т.д. В отличие от стандартных HTML-атрибутов событий, в React события обрабатываются в синтаксисе CamelCase. Это позволяет создавать более читабельный код и избегать путаницы с HTML. Обработчики событий могут использоваться для управления состоянием, выполнения функций и обновления интерфейса в ответ на действия пользователя, такие как нажатие кнопки или изменение текста в поле ввода. Чтобы обрабатывать события, необходимо создать функцию-обработчик и привязать её к элементу. При работе с методами класса важно использовать `bind`, чтобы сохранить правильный контекст (`this`) при вызове метода. Если это не сделать, `this` внутри метода может ссылаться на глобальный объект, а не на экземпляр класса. Состояние компонента можно изменить при наступлении события, вызвав метод `setState` внутри обработчика, что приведет к повторному рендерингу компонента с обновленными данными.",
  "codeExamples": [
      "function handleClick() {\n  alert('Кнопка нажата!');\n}\n\n<button onClick={handleClick}>Нажми меня</button>;",
      "class Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(state => ({\n      isToggleOn: !state.isToggleOn\n    }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.isToggleOn ? 'Включено' : 'Выключено'}\n      </button>\n    );\n  }\n}"
  ],
  "questions": [
      "Как обрабатывать события в React?",
      "Почему важно использовать bind при работе с методами класса?",
      "Как изменить состояние при наступлении события?"
  ]
 },
 {
  "title": "Управление формами",
  "description": "Научитесь управлять формами и обработкой их данных в React.",
  "topic": "Формы в React",
  "theory": "Формы в React позволяют собирать и обрабатывать пользовательский ввод. Управляемые компоненты являются основой работы с формами в React. Это означает, что значения элементов формы управляются состоянием компонента, что обеспечивает предсказуемое поведение приложения. При изменении ввода пользователя состояние обновляется через обработчик событий, что позволяет компоненту реагировать на изменения. Например, если пользователь вводит текст в поле, метод `handleChange` обновляет состояние с помощью `setState`, что приводит к повторному рендерингу компонента с актуальным значением. Обработка отправки формы осуществляется в методе `handleSubmit`, где можно выполнить действия, такие как валидация данных или отправка их на сервер. Использование управляемых компонентов упрощает управление состоянием форм и делает код более читаемым и поддерживаемым.",
  "codeExamples": [
      "class NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('Отправленное имя: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Имя:\n          <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"Отправить\" />\n      </form>\n    );\n  }\n}",
  ],
  "questions": [
      "Что такое управляемый компонент в React?",
      "Как обновлять состояние при изменении значения формы?",
      "Как обработать отправку формы в React?"
  ]
},
{
  "title": "Работа с API",
  "description": "Узнайте, как взаимодействовать с внешними API в React.",
  "topic": "Взаимодействие с API",
  "theory": "Работа с API в React включает выполнение запросов к внешним сервисам для получения или отправки данных. Обычно это делается с помощью встроенной функции `fetch` или библиотек, таких как Axios, которые упрощают процесс работы с HTTP-запросами. Хук `useEffect` используется для выполнения побочных эффектов, таких как запросы к API, и позволяет управлять жизненным циклом компонента. Например, можно использовать `useEffect` для выполнения запроса при первом рендере компонента, передав пустой массив зависимостей. Хук `useState` позволяет хранить полученные данные в состоянии компонента, что обеспечивает их доступность для рендеринга. Важно также обрабатывать ошибки, возникающие при выполнении запросов, чтобы пользователь мог видеть сообщение об ошибке или повторить попытку. Управление состоянием загрузки данных (например, с помощью дополнительного состояния `isLoading`) также улучшает пользовательский опыт, позволяя отображать индикатор загрузки во время ожидания ответа от сервера.",
  "codeExamples": [
    "useEffect(() => {\n  fetch('https://api.example.com/data')\n    .then(response => response.json())\n    .then(data => setData(data))\n    .catch(error => console.error('Ошибка:', error));\n}, []);",
    "async function fetchData() {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    if (!response.ok) {\n      throw new Error('Сеть не в порядке');\n    }\n    const data = await response.json();\n    setData(data);\n  } catch (error) {\n    console.error('Ошибка:', error);\n  }\n}"
  ],
  "questions": [
      "Как выполнять запросы к API в React?",
      "Для чего используется useEffect при работе с запросами?",
      "Как управлять состоянием при получении данных с API?"
  ]
},
{
  "title": "Роутинг в React",
  "description": "Научитесь использовать React Router для маршрутизации.",
  "topic": "Маршрутизация в React",
  "theory": "React Router — это библиотека для маршрутизации в React-приложениях, которая позволяет определять маршруты и управлять навигацией в приложении. С помощью React Router можно создавать маршруты, по которым пользователи могут перемещаться, отображая соответствующие компоненты в зависимости от URL. Библиотека поддерживает динамические маршруты, что позволяет передавать параметры через URL и использовать их в компонентах. Например, можно создать маршрут для отображения профиля пользователя с ID, переданным в URL. Вложенные маршруты позволяют организовать структуру приложения, где один маршрут может содержать другие маршруты. Также React Router предоставляет компонент `<Link>`, который позволяет создавать навигационные ссылки без перезагрузки страницы, что делает приложение более отзывчивым. Важно правильно настраивать маршруты и обрабатывать случаи, когда маршрут не найден, чтобы обеспечить хороший пользовательский опыт.",
  "codeExamples": [
    "import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/about\">\n          <About />\n        </Route>\n        <Route path=\"/user/:id\">\n          <UserProfile />\n        </Route>\n        <Route path=\"/\">\n          <Home />\n        </Route>\n      </Switch>\n    </Router>\n  );\n}",
    "<Link to=\"/about\">О нас</Link>"
  ],
  "questions": [
      "Что такое React Router?",
      "Как создать маршруты в React?",
      "Как использовать параметры в маршрутах?"
  ]
},
{
  "title": "Хуки в React",
  "description": "Изучите хуки и их использование для управления состоянием и жизненным циклом.",
  "topic": "Хуки в React",
  "theory": "Хуки были введены в React 16.8 и позволяют использовать состояние и другие возможности React в функциональных компонентах, что упрощает разработку и делает код более понятным. Хуки заменяют необходимость в классовых компонентах для управления состоянием и жизненным циклом, что позволяет разработчикам писать более чистый и лаконичный код. Основные хуки включают `useState`, который позволяет добавлять состояние в функциональные компоненты, и `useEffect`, который выполняет побочные эффекты, такие как запросы к API, работа с таймерами или подписка на события. `useEffect` также позволяет управлять жизненным циклом компонента, заменяя методы жизненного цикла классовых компонентов, такие как `componentDidMount` и `componentDidUpdate`. Хуки позволяют делить логику состояния и побочных эффектов на переиспользуемые функции, что делает код более модульным и тестируемым.",
  "codeExamples": [
    "const [count, setCount] = useState(0);\nreturn (\n  <div>\n    <p>Вы нажали {count} раз</p>\n    <button onClick={() => setCount(count + 1)}>\n      Нажми меня\n    </button>\n  </div>\n);",
    "useEffect(() => {\n  console.log('Количество изменилось:', count);\n}, [count]);"
  ],
  "questions": [
    "Что такое хуки в React?",
    "Как использовать useState и useEffect?",
    "Как хуки изменили функциональные компоненты в React?"
  ]
},
{
  "title": "Контекст в React",
  "description": "Изучите использование контекста для управления глобальным состоянием.",
  "topic": "Контекст в React",
  "theory": "Контекст в React позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на каждом уровне. Это особенно полезно для управления глобальным состоянием, темами оформления, текущим пользователем и другими данными, которые могут быть доступны нескольким компонентам. Создание контекста включает три основных шага: создание объекта контекста с помощью `React.createContext`, предоставление значения контекста через компонент `Provider`, и потребление значения в дочерних компонентах с помощью компонента `Consumer` или хуков `useContext`. Использование контекста помогает избежать 'проброса' пропсов через множество уровней, что делает код более чистым и удобным для сопровождения. Однако следует учитывать, что частые изменения значения контекста могут привести к лишним рендерам компонентов, поэтому контекст лучше использовать для данных, которые не изменяются слишком часто.",
  "codeExamples": [
    "const ThemeContext = React.createContext('light');\n\nfunction ThemedButton() {\n  return (\n    <ThemeContext.Consumer>\n      {theme => <button className={theme}>Theme Button</button>}\n    </ThemeContext.Consumer>\n  );\n}",
    "function App() {\n  return (\n    <ThemeContext.Provider value='dark'>\n      <ThemedButton />\n    </ThemeContext.Provider>\n  );\n}"
  ],
  "questions": [
      "Что такое контекст в React?",
      "Как создать и использовать контекст?",
      "Какой компонент используется для предоставления значения контекста?"
  ]
},
{
  "title": "Анимации в React",
  "description": "Научитесь добавлять анимации в React-приложения.",
  "topic": "Анимации в React",
  "theory": "Анимации в React могут быть реализованы с помощью CSS или библиотек, таких как React Transition Group и Framer Motion. React Transition Group предоставляет компоненты для управления переходами между состояниями, позволяя легко добавлять анимации при монтировании и размонтировании компонентов. Это особенно полезно для создания простых анимаций, таких как плавное появление или исчезновение элементов. Framer Motion, с другой стороны, предлагает более продвинутые возможности для создания сложных анимаций и взаимодействий. Он позволяет легко анимировать свойства компонентов, такие как положение, размер и прозрачность, с помощью декларативного синтаксиса. Оба подхода могут быть использованы в зависимости от сложности анимаций и предпочтений разработчика. Важно учитывать производительность при использовании анимаций, так как сложные анимации могут негативно сказаться на отзывчивости приложения.",
  "codeExamples": [
    "import { CSSTransition, TransitionGroup } from 'react-transition-group';\n\nfunction Example() {\n  return (\n    <TransitionGroup>\n      <CSSTransition key={key} classNames='fade' timeout={500}>\n        <div>Animated Content</div>\n      </CSSTransition>\n    </TransitionGroup>\n  );\n}",
    "import { motion } from 'framer-motion';\n\nfunction Example() {\n  return (\n    <motion.div animate={{ scale: 1.5 }} transition={{ duration: 0.5 }}>\n      Animated Content\n    </motion.div>\n  );\n}"
  ],
  "questions": [
      "Какие библиотеки для анимаций вы знаете?",
      "Как использовать React Transition Group для анимаций?",
      "Что такое Framer Motion и как его использовать?"
  ]
},
{
  "title": "Состояние и Жизненный Цикл",
  "description": "Понимание состояния и жизненного цикла компонентов.",
  "topic": "Состояние и жизненный цикл",
  "theory": "Состояние (state) в React — это объект, который управляет данными, изменяющимися во время жизни компонента. Оно используется для управления внутренними данными компонента и влияет на его рендеринг. Изменение состояния вызывает повторный рендеринг компонента, что позволяет отображать актуальную информацию. Жизненный цикл компонента в React делится на три основных фазы: монтирование (создание и добавление компонента в DOM), обновление (изменение состояния или пропсов) и размонтирование (удаление компонента из DOM). Методы жизненного цикла, такие как `componentDidMount`, `componentDidUpdate` и `componentWillUnmount`, позволяют выполнять действия в соответствующих фазах, обеспечивая контроль над поведением компонента. Например, `componentDidMount` используется для выполнения действий после того, как компонент был смонтирован, таких как запросы к API. Чтобы изменить состояние компонента, используется метод `setState`, который принимает объект или функцию, обновляющую состояние. Это позволяет управлять динамическими изменениями данных в приложении.",
    "codeExamples": [
      "class Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Привет, мир!</h1>\n        <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}",
    ],
    "questions": [
      "Каково предназначение состояния в React?",
      "Какие методы жизненного цикла вы знаете?",
      "Как изменить состояние компонента?"
    ]
  },
  {
    "title": "Мемоизация и Производительность",
    "description": "Узнайте, как использовать мемоизацию для повышения производительности.",
    "topic": "Мемоизация в React",
    "theory": "Мемоизация в React — это процесс сохранения результатов вычислений, чтобы избежать повторных вычислений при одинаковых входных данных. Это особенно важно для повышения производительности в приложениях, где компоненты могут рендериться многократно с одинаковыми данными. Хуки `useMemo` и `useCallback` позволяют оптимизировать производительность, сохраняя результаты и функции между рендерами. `useMemo` используется для кэширования значений, которые требуют дорогостоящих вычислений, тогда как `useCallback` сохраняет функции, предотвращая их пересоздание при каждом рендере. Это помогает избежать ненужных рендеров дочерних компонентов, которые зависят от этих функций. Кроме того, `React.memo` позволяет мемоизировать целые компоненты, предотвращая их перерисовку, если пропсы не изменились. Важно помнить, что мемоизация может быть полезной, но не всегда необходима; её следует использовать только в тех случаях, когда производительность действительно страдает из-за частых рендеров.",
    "codeExamples": [
      "const MyComponent = React.memo(function MyComponent({prop1, prop2}) {\n  return <div>{prop1} {prop2}</div>;\n});",
      "const handleClick = useCallback(() => {\n  console.log('Clicked!');\n}, []);"
    ],
    "questions": [
      "Как мемоизация помогает улучшить производительность?",
      "Как использовать React.memo для оптимизации?",
      "В чем разница между useMemo и useCallback?"
    ]
  },
  {
    "title": "Серверный рендеринг (SSR) с Next.js",
    "description": "Узнайте, как использовать серверный рендеринг в React с помощью Next.js.",
    "topic": "Серверный рендеринг (SSR)",
    "theory": "Серверный рендеринг (SSR) — это процесс генерации HTML на сервере, который затем отправляется клиенту. Это позволяет улучшить SEO и ускорить время загрузки, так как первоначальный контент доступен пользователю сразу. Next.js — это популярный фреймворк для React, который поддерживает серверный рендеринг из коробки. Он предоставляет удобные функции для создания серверных маршрутов, предзагрузки данных и рендеринга страниц на сервере. Компоненты, рендерящиеся на сервере, получают данные на этапе сборки или на стороне сервера с использованием методов `getStaticProps` и `getServerSideProps`. Это позволяет предзагружать контент и обеспечивать его актуальность перед отправкой клиенту. В Next.js также можно комбинировать SSR с клиентским рендерингом, чтобы создать гибкие и производительные приложения.",
    "codeExamples": [
      "import React from 'react';\n\nexport async function getServerSideProps() {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return { props: { data } };\n}\n\nfunction MyPage({ data }) {\n  return <div>{JSON.stringify(data)}</div>;\n}\n\nexport default MyPage;",
      "import React from 'react';\nimport Link from 'next/link';\n\nexport default function Home() {\n  return (\n    <div>\n      <h1>Welcome to Next.js!</h1>\n      <Link href='/about'>Learn more about us</Link>\n    </div>\n  );\n}"
    ],
    "questions": [
      "Что такое серверный рендеринг и как он работает?",
      "Какие преимущества даёт использование Next.js для SSR?",
      "В чем разница между getStaticProps и getServerSideProps?"
    ]
  },
  {
    "title": "Оптимизация производительности в React",
    "description": "Узнайте, как оптимизировать производительность React-приложений.",
    "topic": "Оптимизация производительности",
    "theory": "Оптимизация производительности в React-приложениях необходима для того, чтобы интерфейсы оставались отзывчивыми и быстрыми, даже при больших объемах данных или сложных компонентах. Важной техникой является мемоизация, которая позволяет избегать повторных вычислений или рендеров при одинаковых входных данных. Хук `useMemo` используется для кэширования значений, требующих дорогостоящих вычислений. Например, если функция возвращает отфильтрованный список, `useMemo` предотвратит повторное выполнение этой операции при каждом рендере, если входные данные не изменились. Хук `useCallback` позволяет мемоизировать функции, предотвращая их пересоздание при каждом рендере, что также может уменьшить количество ненужных рендеров дочерних компонентов. Компонент `React.memo` мемоизирует сами компоненты, предотвращая их рендеринг, если их пропсы не изменились. Это полезно для компонент, которые рендерятся с одинаковыми данными. Еще одной важной техникой является ленивый импорт компонентов с использованием `React.lazy` и `Suspense`, что позволяет загружать компоненты только тогда, когда они действительно нужны, уменьшая время начальной загрузки приложения. Эти методы помогают оптимизировать производительность, снижая нагрузку на процессор и сокращая время рендеринга компонентов.",
    "codeExamples": [
      "const MemoizedComponent = React.memo(function MyComponent({ data }) {\n  return <div>{data}</div>;\n});",
      "const filteredData = useMemo(() => data.filter(item => item.active), [data]);",
      "const handleClick = useCallback(() => {\n  console.log('Clicked!');\n}, []);"
    ],
    "questions": [
      "Какие техники используются для оптимизации производительности в React?",
      "Как `useMemo` помогает улучшить производительность?",
      "Почему `useCallback` полезен при оптимизации производительности?",
      "Что делает `React.memo` и когда его следует использовать?"
    ]
  }  
];

export default lessonsData;

